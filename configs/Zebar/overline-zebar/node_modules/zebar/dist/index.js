// src/config/config-schemas.ts
import { z } from "zod";
var length = z.string().regex(
  /^([+-]?\d+(?:\.\d+)?)(%|px)?$/,
  "Not a valid length value. Must be of format '10px' or '10%'."
);
var name = z.string().min(2, "Name must be at least 2 characters.").max(28, "Name cannot exceed 28 characters.").regex(
  /^[a-z0-9][a-z0-9-_]*$/,
  "Only lowercase letters, numbers, and the characters - and _ are allowed."
);
var version = z.string().regex(
  /^[0-9]{1,4}\.[0-9]{1,4}\.[0-9]{1,4}$/,
  'Version must be in the format "x.y.z" (e.g. "1.0.0").'
);
var widget = z.object({
  name,
  htmlPath: z.string().refine((path) => path.endsWith(".html"), {
    message: 'Must be a valid HTML file path (e.g. "path/to/widget.html").'
  }),
  zOrder: z.enum(["normal", "top_most", "bottom_most"]),
  shownInTaskbar: z.boolean(),
  focused: z.boolean(),
  resizable: z.boolean(),
  transparent: z.boolean(),
  includeFiles: z.array(z.string()).default([]),
  caching: z.object({
    defaultDuration: z.number(),
    rules: z.array(
      z.object({
        urlRegex: z.string(),
        duration: z.number()
      })
    )
  }),
  privileges: z.object({
    shellCommands: z.array(
      z.object({
        program: z.string(),
        argsRegex: z.string()
      })
    )
  }),
  presets: z.array(
    z.object({
      name: z.string(),
      anchor: z.enum([
        "top_left",
        "top_center",
        "top_right",
        "center_left",
        "center",
        "center_right",
        "bottom_left",
        "bottom_center",
        "bottom_right"
      ]),
      offsetX: length,
      offsetY: length,
      width: length,
      height: length,
      monitorSelection: z.union([
        z.object({
          type: z.literal("all")
        }),
        z.object({
          type: z.literal("primary")
        }),
        z.object({
          type: z.literal("secondary")
        }),
        z.object({
          type: z.literal("index"),
          match: z.number()
        }),
        z.object({
          type: z.literal("name"),
          match: z.string()
        })
      ]),
      dockToEdge: z.object({
        enabled: z.boolean(),
        edge: z.enum(["top", "right", "bottom", "left"]).nullable(),
        windowMargin: z.string()
      })
    })
  )
});
var widgetPack = z.object({
  name,
  version,
  description: z.string().max(1e3, "Description cannot exceed 1000 characters."),
  tags: z.array(z.string()).max(10, "At most 10 tags are allowed."),
  previewImages: z.array(
    z.string().refine((url) => !url.startsWith("http"), {
      message: "Preview image must be a file within the widget pack."
    }).refine((url) => !url.includes(":\\") && !url.startsWith("/"), {
      message: 'Preview image must be a relative file path (e.g. "resources/preview.png")'
    })
  ).min(1, "At least one preview image is required.").max(6, "At most 6 preview images are allowed."),
  widgets: z.array(widget),
  repositoryUrl: z.string().url().or(z.literal(""))
});
var configSchemas = {
  length,
  name,
  version,
  widget,
  widgetPack
};

// src/desktop/desktop-commands.ts
import {
  invoke as tauriInvoke
} from "@tauri-apps/api/core";

// src/utils/create-logger.ts
function createLogger(section) {
  function log(consoleLogMethod, message, ...data) {
    const date = /* @__PURE__ */ new Date();
    const timestamp = `${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}:${date.getMilliseconds().toString().padStart(3, "0")}`;
    console[consoleLogMethod](
      `%c[Zebar] %c${timestamp}%c${section ? ` (${section})` : ""} %c${message}`,
      "color: #4ade80",
      "color: #f5f9b4",
      "color: #d0b4f9",
      "color: inherit",
      ...data
    );
  }
  function debug(message, ...data) {
    log("log", message, ...data);
  }
  function info(message, ...data) {
    log("log", message, ...data);
  }
  function warn(message, ...data) {
    log("warn", message, ...data);
  }
  function error(message, ...data) {
    log("error", message, ...data);
  }
  return {
    debug,
    info,
    warn,
    error
  };
}

// src/utils/get-coordinate-distance.ts
function getCoordinateDistance(pointA, pointB) {
  return Math.sqrt(
    Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2)
  );
}

// src/utils/simple-hash.ts
function simpleHash(...args) {
  return JSON.stringify(
    args,
    (_, val) => typeof val === "object" ? val : String(val)
  );
}

// src/desktop/desktop-commands.ts
var logger = createLogger();
var desktopCommands = {
  startWidget,
  startWidgetPreset,
  listenProvider,
  unlistenProvider,
  callProviderFunction,
  setAlwaysOnTop,
  setSkipTaskbar,
  shellExec,
  shellSpawn,
  shellWrite,
  shellKill
};
function startWidget(packId, widgetName, placement, isPreview) {
  return invoke("start_widget", {
    packId,
    widgetName,
    placement,
    isPreview
  });
}
function startWidgetPreset(packId, widgetName, presetName, isPreview) {
  return invoke("start_widget_preset", {
    packId,
    widgetName,
    presetName,
    isPreview
  });
}
function listenProvider(args) {
  return invoke("listen_provider", args);
}
function unlistenProvider(configHash) {
  return invoke("unlisten_provider", { configHash });
}
function callProviderFunction(configHash, fn) {
  return invoke("call_provider_function", {
    configHash,
    function: fn
  });
}
function setAlwaysOnTop() {
  return invoke("set_always_on_top");
}
function setSkipTaskbar(skip) {
  return invoke("set_skip_taskbar", { skip });
}
function shellExec(program, args = [], options = {}) {
  return invoke("shell_exec", {
    program,
    args,
    options
  });
}
function shellSpawn(program, args = [], options = {}) {
  return invoke("shell_spawn", { program, args, options });
}
function shellWrite(processId, buffer) {
  return invoke("shell_write", { processId, buffer });
}
function shellKill(processId) {
  return invoke("shell_kill", { processId });
}
async function invoke(command, args) {
  logger.info(`Calling '${command}' with args:`, args ?? {});
  try {
    const response = await tauriInvoke(command, args);
    logger.info(`Response for calling '${command}':`, response);
    return response;
  } catch (err) {
    logger.error(`Command '${command}' failed: ${err}`);
    throw new Error(`Command '${command}' failed: ${err}`);
  }
}

// src/desktop/monitors.ts
import {
  availableMonitors as getAvailableMonitors,
  currentMonitor as getCurrentMonitor,
  primaryMonitor as getPrimaryMonitor,
  getCurrentWindow
} from "@tauri-apps/api/window";
var createCachePromise = null;
async function getMonitors() {
  return createCachePromise ?? (createCachePromise = createMonitorCache());
}
async function createMonitorCache() {
  const [currentMonitor, primaryMonitor, allMonitors] = await Promise.all([
    getCurrentMonitor(),
    getPrimaryMonitor(),
    getAvailableMonitors()
  ]);
  const secondaryMonitors = allMonitors.filter(
    (monitor) => !primaryMonitor || !isMatch(monitor, primaryMonitor)
  );
  const monitorCache = {
    currentMonitor: currentMonitor ? toMonitor(currentMonitor) : null,
    primaryMonitor: primaryMonitor ? toMonitor(primaryMonitor) : null,
    secondaryMonitors: secondaryMonitors.map(toMonitor),
    allMonitors: allMonitors.map(toMonitor)
  };
  getCurrentWindow().onResized(() => updateCurrentMonitor());
  getCurrentWindow().onMoved(() => updateCurrentMonitor());
  async function updateCurrentMonitor() {
    const currentMonitor2 = await getCurrentMonitor();
    Object.assign(monitorCache, {
      currentMonitor: currentMonitor2 ? toMonitor(currentMonitor2) : null
    });
  }
  return monitorCache;
}
function isMatch(monitorA, monitorB) {
  return monitorA.name === monitorB.name && monitorA.position.x === monitorB.position.x && monitorA.position.y === monitorB.position.y && monitorA.size.width === monitorB.size.width && monitorA.size.height === monitorB.size.height;
}
function toMonitor(monitor) {
  return {
    name: monitor.name,
    width: monitor.size.width,
    height: monitor.size.height,
    x: monitor.position.x,
    y: monitor.position.y,
    scaleFactor: monitor.scaleFactor
  };
}

// src/desktop/provider-emit.ts
import {
  listen
} from "@tauri-apps/api/event";
var listenPromise = null;
var callbacks = [];
async function onProviderEmit(config, callback) {
  const configHash = simpleHash(config);
  registerEventCallback(configHash, callback);
  const unlisten = await (listenPromise ?? (listenPromise = listenProviderEmit()));
  await desktopCommands.listenProvider({
    configHash,
    config
  });
  return async () => {
    callbacks = callbacks.filter(
      (callback2) => callback2.configHash !== configHash
    );
    await desktopCommands.unlistenProvider(configHash);
    if (callbacks.length === 0) {
      unlisten();
      listenPromise = null;
    }
  };
}
function registerEventCallback(configHash, callback) {
  const wrappedCallback = (event) => {
    if (event.payload.configHash !== configHash) {
      return;
    }
    callback(event.payload);
  };
  callbacks.push({ configHash, fn: wrappedCallback });
}
async function listenProviderEmit() {
  return listen("provider-emit", (event) => {
    callbacks.forEach((callback) => {
      if (event.payload.configHash === callback.configHash) {
        callback.fn(event);
      }
    });
  });
}

// src/desktop/shell.ts
import { listen as listen2 } from "@tauri-apps/api/event";
async function shellExec2(program, args, options) {
  return await desktopCommands.shellExec(program, args, options);
}
async function shellSpawn2(program, args, options) {
  const processId = await desktopCommands.shellSpawn(
    program,
    args,
    options
  );
  const stdoutCallbacks = [];
  const stderrCallbacks = [];
  const errorCallbacks = [];
  const exitCallbacks = [];
  const unlistenEvents = await listen2(
    "shell-emit",
    (event) => {
      if (event.payload.pid === processId) {
        const shellEvent = event.payload.event;
        switch (shellEvent.type) {
          case "stdout":
            stdoutCallbacks.forEach(
              (callback) => callback(shellEvent.data)
            );
            break;
          case "stderr":
            stderrCallbacks.forEach(
              (callback) => callback(shellEvent.data)
            );
            break;
          case "error":
            errorCallbacks.forEach((callback) => callback(shellEvent.data));
            break;
          case "terminated":
            exitCallbacks.forEach((callback) => callback(shellEvent.data));
            unlistenEvents();
            break;
        }
      }
    }
  );
  return {
    processId,
    onStdout: (callback) => stdoutCallbacks.push(callback),
    onStderr: (callback) => stderrCallbacks.push(callback),
    onExit: (callback) => exitCallbacks.push(callback),
    kill: () => desktopCommands.shellKill(processId),
    write: (data) => desktopCommands.shellWrite(processId, data)
  };
}

// src/desktop/widgets.ts
import { getCurrentWindow as getCurrentWindow2 } from "@tauri-apps/api/window";
function getWidgetState() {
  if (window.__ZEBAR_STATE) {
    return window.__ZEBAR_STATE;
  }
  const widgetState = sessionStorage.getItem("ZEBAR_STATE");
  if (!widgetState) {
    throw new Error("No widget state found.");
  }
  return JSON.parse(widgetState);
}
function currentWidget() {
  const state = getWidgetState();
  const tauriWindow = getCurrentWindow2();
  return {
    id: state.id,
    name: state.name,
    packId: state.packId,
    configPath: state.configPath,
    htmlPath: state.htmlPath,
    window: {
      get tauri() {
        return tauriWindow;
      },
      setZOrder: (zOrder) => setZOrder(tauriWindow, zOrder)
    },
    tauriWindow,
    isPreview: state.isPreview,
    setZOrder: (zOrder) => setZOrder(tauriWindow, zOrder),
    close: () => close(tauriWindow)
  };
}
async function setZOrder(window2, zOrder) {
  if (zOrder === "bottom_most") {
    await window2.setAlwaysOnBottom(true);
  } else if (zOrder === "top_most") {
    await desktopCommands.setAlwaysOnTop();
  } else {
    await window2.setAlwaysOnTop(false);
  }
}
async function close(window2) {
  await window2.close();
}
async function startWidget2(widgetName, placement, args) {
  return desktopCommands.startWidget(
    args.packId ?? currentWidget().packId,
    widgetName,
    placement,
    getWidgetState().isPreview
  );
}
async function startWidgetPreset2(widgetName, presetName, args) {
  return desktopCommands.startWidgetPreset(
    args?.packId ?? currentWidget().packId,
    widgetName,
    presetName,
    getWidgetState().isPreview
  );
}

// src/providers/audio/create-audio-provider.ts
import { z as z2 } from "zod";

// src/providers/create-base-provider.ts
function createBaseProvider(config, fetcher) {
  const logger2 = createLogger(config.type);
  const outputListeners = /* @__PURE__ */ new Set();
  const errorListeners = /* @__PURE__ */ new Set();
  let latestEmission = {
    output: null,
    error: null,
    hasError: false
  };
  let unlisten = startFetcher();
  function startFetcher() {
    return fetcher({
      output: (output) => {
        logger2.debug("Provider output:", output);
        latestEmission = { output, error: null, hasError: false };
        outputListeners.forEach((listener) => listener(output));
      },
      error: (error) => {
        logger2.warn("Provider error:", error);
        latestEmission = { output: null, error, hasError: true };
        errorListeners.forEach((listener) => listener(error));
      }
    });
  }
  return {
    get output() {
      return latestEmission.output;
    },
    get error() {
      return latestEmission.error;
    },
    get hasError() {
      return latestEmission.hasError;
    },
    config,
    restart: async () => {
      if (unlisten) {
        await (await unlisten)();
      }
      unlisten = startFetcher();
    },
    stop: async () => {
      outputListeners.clear();
      errorListeners.clear();
      if (unlisten) {
        await (await unlisten)();
        unlisten = null;
      }
    },
    onOutput: (callback) => {
      outputListeners.add(callback);
    },
    onError: (callback) => {
      errorListeners.add(callback);
    }
  };
}

// src/providers/audio/create-audio-provider.ts
var audioProviderConfigSchema = z2.object({
  type: z2.literal("audio")
});
function createAudioProvider(config) {
  const mergedConfig = audioProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(
      mergedConfig,
      ({ configHash, result }) => {
        if ("error" in result) {
          queue.error(result.error);
        } else {
          queue.output({
            ...result.output,
            setVolume: (volume, options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "audio",
                function: {
                  name: "set_volume",
                  args: { volume, deviceId: options?.deviceId }
                }
              });
            },
            setMute: (mute, options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "audio",
                function: {
                  name: "set_mute",
                  args: { mute, deviceId: options?.deviceId }
                }
              });
            }
          });
        }
      }
    );
  });
}

// src/providers/battery/create-battery-provider.ts
import { z as z3 } from "zod";
var batteryProviderConfigSchema = z3.object({
  type: z3.literal("battery"),
  refreshInterval: z3.coerce.number().default(60 * 1e3)
});
function createBatteryProvider(config) {
  const mergedConfig = batteryProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/cpu/create-cpu-provider.ts
import { z as z4 } from "zod";
var cpuProviderConfigSchema = z4.object({
  type: z4.literal("cpu"),
  refreshInterval: z4.coerce.number().default(5 * 1e3)
});
function createCpuProvider(config) {
  const mergedConfig = cpuProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/date/create-date-provider.ts
import { DateTime } from "luxon";
import { z as z5 } from "zod";
var dateProviderConfigSchema = z5.object({
  type: z5.literal("date"),
  refreshInterval: z5.coerce.number().default(1e3),
  timezone: z5.string().default("local"),
  locale: z5.string().optional(),
  formatting: z5.string().default("EEE	d MMM t")
});
function createDateProvider(config) {
  const mergedConfig = dateProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    queue.output(getDateValue());
    const interval = setInterval(
      () => queue.output(getDateValue()),
      mergedConfig.refreshInterval
    );
    function getDateValue() {
      const dateTime = DateTime.now().setZone(mergedConfig.timezone);
      return {
        new: dateTime.toJSDate(),
        now: dateTime.toMillis(),
        iso: dateTime.toISO(),
        formatted: dateTime.toFormat(mergedConfig.formatting, {
          locale: mergedConfig.locale
        })
      };
    }
    return () => {
      clearInterval(interval);
    };
  });
}

// src/providers/glazewm/create-glazewm-provider.ts
import {
  WmClient,
  WmEventType
} from "glazewm";
import { z as z6 } from "zod";
var glazeWmProviderConfigSchema = z6.object({
  type: z6.literal("glazewm")
});
function createGlazeWmProvider(config) {
  const mergedConfig = glazeWmProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    const monitors = await getMonitors();
    const client = new WmClient();
    let unlistenEvents = null;
    client.onDisconnect(
      () => queue.error("Failed to connect to GlazeWM IPC server.")
    );
    client.onConnect(async () => {
      let state = await getInitialState();
      queue.output(state);
      unlistenEvents ??= await client.subscribe(WmEventType.ALL, onEvent);
      async function onEvent(e) {
        switch (e.eventType) {
          case WmEventType.BINDING_MODES_CHANGED: {
            state = { ...state, bindingModes: e.newBindingModes };
            break;
          }
          case WmEventType.FOCUS_CHANGED: {
            state = { ...state, focusedContainer: e.focusedContainer };
            state = { ...state, ...await getMonitorState() };
            const { tilingDirection } = await client.queryTilingDirection();
            state = { ...state, tilingDirection };
            break;
          }
          case WmEventType.FOCUSED_CONTAINER_MOVED: {
            state = { ...state, focusedContainer: e.focusedContainer };
            state = { ...state, ...await getMonitorState() };
            break;
          }
          case WmEventType.TILING_DIRECTION_CHANGED: {
            state = { ...state, tilingDirection: e.newTilingDirection };
            break;
          }
          case WmEventType.WORKSPACE_ACTIVATED:
          case WmEventType.WORKSPACE_DEACTIVATED:
          case WmEventType.WORKSPACE_UPDATED: {
            state = { ...state, ...await getMonitorState() };
            break;
          }
          case WmEventType.PAUSE_CHANGED: {
            state = { ...state, isPaused: e.isPaused };
            break;
          }
        }
        queue.output(state);
      }
      function runCommand(command, subjectContainerId) {
        return client.runCommand(command, subjectContainerId);
      }
      async function getInitialState() {
        const { focused: focusedContainer } = await client.queryFocused();
        const { bindingModes } = await client.queryBindingModes();
        const { tilingDirection } = await client.queryTilingDirection();
        const isPaused = await getIsPaused();
        return {
          ...await getMonitorState(),
          focusedContainer,
          tilingDirection,
          bindingModes,
          isPaused,
          runCommand
        };
      }
      async function getIsPaused() {
        try {
          const { paused } = await client.queryPaused();
          return paused;
        } catch {
          return false;
        }
      }
      async function getMonitorState() {
        const currentPosition = {
          x: monitors.currentMonitor.x,
          y: monitors.currentMonitor.y
        };
        const { monitors: glazeWmMonitors } = await client.queryMonitors();
        const { windows: glazeWmWindows } = await client.queryWindows();
        const currentGlazeWmMonitor = glazeWmMonitors.reduce(
          (a, b) => getCoordinateDistance(currentPosition, a) < getCoordinateDistance(currentPosition, b) ? a : b
        );
        const focusedGlazeWmMonitor = glazeWmMonitors.find(
          (monitor) => monitor.hasFocus
        );
        const allGlazeWmWorkspaces = glazeWmMonitors.flatMap(
          (monitor) => monitor.children
        );
        const focusedGlazeWmWorkspace = focusedGlazeWmMonitor?.children.find(
          (workspace) => workspace.hasFocus
        );
        const displayedGlazeWmWorkspace = currentGlazeWmMonitor.children.find(
          (workspace) => workspace.isDisplayed
        );
        return {
          displayedWorkspace: displayedGlazeWmWorkspace,
          focusedWorkspace: focusedGlazeWmWorkspace,
          currentWorkspaces: currentGlazeWmMonitor.children,
          allWorkspaces: allGlazeWmWorkspaces,
          focusedMonitor: focusedGlazeWmMonitor,
          currentMonitor: currentGlazeWmMonitor,
          allMonitors: glazeWmMonitors,
          allWindows: glazeWmWindows
        };
      }
    });
    return () => {
      unlistenEvents?.();
      client.closeConnection();
    };
  });
}

// src/providers/host/create-host-provider.ts
import { z as z7 } from "zod";
var hostProviderConfigSchema = z7.object({
  type: z7.literal("host"),
  refreshInterval: z7.coerce.number().default(60 * 1e3)
});
function createHostProvider(config) {
  const mergedConfig = hostProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/ip/create-ip-provider.ts
import { z as z8 } from "zod";
var ipProviderConfigSchema = z8.object({
  type: z8.literal("ip"),
  refreshInterval: z8.coerce.number().default(60 * 60 * 1e3)
});
function createIpProvider(config) {
  const mergedConfig = ipProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/keyboard/create-keyboard-provider.ts
import { z as z9 } from "zod";
var keyboardProviderConfigSchema = z9.object({
  type: z9.literal("keyboard"),
  refreshInterval: z9.coerce.number().default(1e3)
});
function createKeyboardProvider(config) {
  const mergedConfig = keyboardProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/komorebi/create-komorebi-provider.ts
import { z as z10 } from "zod";
var komorebiProviderConfigSchema = z10.object({
  type: z10.literal("komorebi")
});
function createKomorebiProvider(config) {
  const mergedConfig = komorebiProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    const monitors = await getMonitors();
    async function getUpdatedState(res) {
      const currentPosition = {
        x: monitors.currentMonitor.x,
        y: monitors.currentMonitor.y
      };
      const currentKomorebiMonitor = res.allMonitors.reduce(
        (a, b) => getCoordinateDistance(currentPosition, {
          x: a.workAreaSize.left,
          y: a.workAreaSize.top
        }) < getCoordinateDistance(currentPosition, {
          x: b.workAreaSize.left,
          y: b.workAreaSize.top
        }) ? a : b
      );
      const displayedKomorebiWorkspace = currentKomorebiMonitor.workspaces[currentKomorebiMonitor.focusedWorkspaceIndex];
      const allKomorebiWorkspaces = res.allMonitors.flatMap(
        (monitor) => monitor.workspaces
      );
      const focusedKomorebiMonitor = res.allMonitors[res.focusedMonitorIndex];
      const focusedKomorebiWorkspace = focusedKomorebiMonitor.workspaces[focusedKomorebiMonitor.focusedWorkspaceIndex];
      return {
        displayedWorkspace: displayedKomorebiWorkspace,
        focusedWorkspace: focusedKomorebiWorkspace,
        currentWorkspaces: currentKomorebiMonitor.workspaces,
        allWorkspaces: allKomorebiWorkspaces,
        focusedMonitor: focusedKomorebiMonitor,
        currentMonitor: currentKomorebiMonitor,
        allMonitors: res.allMonitors
      };
    }
    return onProviderEmit(
      mergedConfig,
      async ({ result }) => {
        if ("error" in result) {
          queue.error(result.error);
        } else {
          const updatedState = await getUpdatedState(result.output);
          queue.output(updatedState);
        }
      }
    );
  });
}

// src/providers/media/create-media-provider.ts
import { z as z11 } from "zod";
var mediaProviderConfigSchema = z11.object({
  type: z11.literal("media")
});
function createMediaProvider(config) {
  const mergedConfig = mediaProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(
      mergedConfig,
      ({ result, configHash }) => {
        if ("error" in result) {
          queue.error(result.error);
        } else {
          queue.output({
            ...result.output,
            session: result.output.currentSession,
            play: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "play",
                  args: options ?? {}
                }
              });
            },
            pause: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "pause",
                  args: options ?? {}
                }
              });
            },
            togglePlayPause: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "toggle_play_pause",
                  args: options ?? {}
                }
              });
            },
            next: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "next",
                  args: options ?? {}
                }
              });
            },
            previous: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "previous",
                  args: options ?? {}
                }
              });
            }
          });
        }
      }
    );
  });
}

// src/providers/memory/create-memory-provider.ts
import { z as z12 } from "zod";
var memoryProviderConfigSchema = z12.object({
  type: z12.literal("memory"),
  refreshInterval: z12.coerce.number().default(5 * 1e3)
});
function createMemoryProvider(config) {
  const mergedConfig = memoryProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/network/create-network-provider.ts
import { z as z13 } from "zod";
var networkProviderConfigSchema = z13.object({
  type: z13.literal("network"),
  refreshInterval: z13.coerce.number().default(5 * 1e3)
});
function createNetworkProvider(config) {
  const mergedConfig = networkProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/weather/create-weather-provider.ts
import { z as z14 } from "zod";
var weatherProviderConfigSchema = z14.object({
  type: z14.literal("weather"),
  latitude: z14.coerce.number().optional(),
  longitude: z14.coerce.number().optional(),
  refreshInterval: z14.coerce.number().default(60 * 60 * 1e3)
});
function createWeatherProvider(config) {
  const mergedConfig = weatherProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/disk/create-disk-provider.ts
import { z as z15 } from "zod";
var diskProviderConfigSchema = z15.object({
  type: z15.literal("disk"),
  refreshInterval: z15.coerce.number().default(60 * 1e3)
});
function createDiskProvider(config) {
  const mergedConfig = diskProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/systray/create-systray-provider.ts
import { z as z16 } from "zod";
var systrayProviderConfigSchema = z16.object({
  type: z16.literal("systray")
});
function createSystrayProvider(config) {
  const mergedConfig = systrayProviderConfigSchema.parse(config);
  const iconCache = /* @__PURE__ */ new Map();
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(
      mergedConfig,
      ({ configHash, result }) => {
        if ("error" in result) {
          queue.error(result.error);
        } else {
          const currentHashes = new Set(
            result.output.icons.map((icon) => icon.iconHash)
          );
          queue.output({
            ...result.output,
            icons: result.output.icons.map((icon) => {
              let cachedIcon = iconCache.get(icon.iconHash);
              if (!icon.iconHash || !cachedIcon) {
                const iconBlob = new Blob(
                  [new Uint8Array(icon.iconBytes)],
                  { type: "image/png" }
                );
                cachedIcon = {
                  iconBlob,
                  iconUrl: URL.createObjectURL(iconBlob)
                };
                iconCache.set(icon.iconHash, cachedIcon);
              }
              return {
                ...icon,
                iconBlob: cachedIcon.iconBlob,
                iconUrl: cachedIcon.iconUrl
              };
            }),
            onHoverEnter: (iconId) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "systray",
                function: {
                  name: "icon_hover_enter",
                  args: { iconId }
                }
              });
            },
            onHoverLeave: (iconId) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "systray",
                function: {
                  name: "icon_hover_leave",
                  args: { iconId }
                }
              });
            },
            onHoverMove: (iconId) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "systray",
                function: {
                  name: "icon_hover_move",
                  args: { iconId }
                }
              });
            },
            onLeftClick: (iconId) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "systray",
                function: {
                  name: "icon_left_click",
                  args: { iconId }
                }
              });
            },
            onRightClick: (iconId) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "systray",
                function: {
                  name: "icon_right_click",
                  args: { iconId }
                }
              });
            },
            onMiddleClick: (iconId) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "systray",
                function: {
                  name: "icon_middle_click",
                  args: { iconId }
                }
              });
            }
          });
          for (const [hash, cachedIcon] of iconCache) {
            if (!currentHashes.has(hash)) {
              URL.revokeObjectURL(cachedIcon.iconUrl);
              iconCache.delete(hash);
            }
          }
        }
      }
    );
  });
}

// src/providers/create-provider.ts
function createProvider(config) {
  switch (config.type) {
    case "audio":
      return createAudioProvider(config);
    case "battery":
      return createBatteryProvider(config);
    case "cpu":
      return createCpuProvider(config);
    case "date":
      return createDateProvider(config);
    case "glazewm":
      return createGlazeWmProvider(config);
    case "host":
      return createHostProvider(config);
    case "ip":
      return createIpProvider(config);
    case "komorebi":
      return createKomorebiProvider(config);
    case "media":
      return createMediaProvider(config);
    case "memory":
      return createMemoryProvider(config);
    case "network":
      return createNetworkProvider(config);
    case "weather":
      return createWeatherProvider(config);
    case "keyboard":
      return createKeyboardProvider(config);
    case "disk":
      return createDiskProvider(config);
    case "systray":
      return createSystrayProvider(config);
    default:
      throw new Error("Not a supported provider type.");
  }
}

// src/providers/create-provider-group.ts
function createProviderGroup(configMap) {
  const outputListeners = /* @__PURE__ */ new Set();
  const errorListeners = /* @__PURE__ */ new Set();
  const providerMap = createProviderMap(configMap);
  let outputMap = Object.fromEntries(
    Object.keys(providerMap).map((name2) => [name2, null])
  );
  let errorMap = Object.fromEntries(
    Object.keys(providerMap).map((name2) => [name2, null])
  );
  for (const [name2, provider] of Object.entries(providerMap)) {
    provider.onOutput(() => {
      outputMap = { ...outputMap, [name2]: provider.output };
      errorMap = { ...errorMap, [name2]: null };
      outputListeners.forEach((listener) => listener(outputMap));
    });
    provider.onError(() => {
      errorMap = { ...errorMap, [name2]: provider.error };
      outputMap = { ...outputMap, [name2]: null };
      errorListeners.forEach((listener) => listener(errorMap));
    });
  }
  return {
    get outputMap() {
      return outputMap;
    },
    get errorMap() {
      return errorMap;
    },
    get hasErrors() {
      return Object.keys(errorMap).length > 0;
    },
    configMap,
    raw: providerMap,
    onOutput: (callback) => {
      outputListeners.add(callback);
    },
    onError: (callback) => {
      errorListeners.add(callback);
    },
    restartAll: async () => {
      await Promise.all(
        Object.values(providerMap).map((provider) => provider.restart())
      );
    },
    stopAll: async () => {
      outputListeners.clear();
      errorListeners.clear();
      await Promise.all(
        Object.values(providerMap).map((provider) => provider.stop())
      );
    }
  };
}
function createProviderMap(configMap) {
  return Object.fromEntries(
    Object.entries(configMap).map(([name2, config]) => [
      name2,
      createProvider(config)
    ])
  );
}
export {
  configSchemas,
  createProvider,
  createProviderGroup,
  currentWidget,
  shellExec2 as shellExec,
  shellSpawn2 as shellSpawn,
  startWidget2 as startWidget,
  startWidgetPreset2 as startWidgetPreset
};
