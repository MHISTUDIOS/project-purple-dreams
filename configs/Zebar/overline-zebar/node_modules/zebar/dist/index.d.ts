import { z } from 'zod';
import { Workspace, Monitor, Window, Container, TilingDirection, BindingModeConfig, RunCommandResponse } from 'glazewm';
import { getCurrentWindow } from '@tauri-apps/api/window';

declare const configSchemas: {
    length: z.ZodString;
    name: z.ZodString;
    version: z.ZodString;
    widget: z.ZodObject<{
        name: z.ZodString;
        htmlPath: z.ZodEffects<z.ZodString, string, string>;
        zOrder: z.ZodEnum<["normal", "top_most", "bottom_most"]>;
        shownInTaskbar: z.ZodBoolean;
        focused: z.ZodBoolean;
        resizable: z.ZodBoolean;
        transparent: z.ZodBoolean;
        includeFiles: z.ZodDefault<z.ZodArray<z.ZodString, "many">>;
        caching: z.ZodObject<{
            defaultDuration: z.ZodNumber;
            rules: z.ZodArray<z.ZodObject<{
                urlRegex: z.ZodString;
                duration: z.ZodNumber;
            }, "strip", z.ZodTypeAny, {
                urlRegex: string;
                duration: number;
            }, {
                urlRegex: string;
                duration: number;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            defaultDuration: number;
            rules: {
                urlRegex: string;
                duration: number;
            }[];
        }, {
            defaultDuration: number;
            rules: {
                urlRegex: string;
                duration: number;
            }[];
        }>;
        privileges: z.ZodObject<{
            shellCommands: z.ZodArray<z.ZodObject<{
                program: z.ZodString;
                argsRegex: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                program: string;
                argsRegex: string;
            }, {
                program: string;
                argsRegex: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            shellCommands: {
                program: string;
                argsRegex: string;
            }[];
        }, {
            shellCommands: {
                program: string;
                argsRegex: string;
            }[];
        }>;
        presets: z.ZodArray<z.ZodObject<{
            name: z.ZodString;
            anchor: z.ZodEnum<["top_left", "top_center", "top_right", "center_left", "center", "center_right", "bottom_left", "bottom_center", "bottom_right"]>;
            offsetX: z.ZodString;
            offsetY: z.ZodString;
            width: z.ZodString;
            height: z.ZodString;
            monitorSelection: z.ZodUnion<[z.ZodObject<{
                type: z.ZodLiteral<"all">;
            }, "strip", z.ZodTypeAny, {
                type: "all";
            }, {
                type: "all";
            }>, z.ZodObject<{
                type: z.ZodLiteral<"primary">;
            }, "strip", z.ZodTypeAny, {
                type: "primary";
            }, {
                type: "primary";
            }>, z.ZodObject<{
                type: z.ZodLiteral<"secondary">;
            }, "strip", z.ZodTypeAny, {
                type: "secondary";
            }, {
                type: "secondary";
            }>, z.ZodObject<{
                type: z.ZodLiteral<"index">;
                match: z.ZodNumber;
            }, "strip", z.ZodTypeAny, {
                type: "index";
                match: number;
            }, {
                type: "index";
                match: number;
            }>, z.ZodObject<{
                type: z.ZodLiteral<"name">;
                match: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                type: "name";
                match: string;
            }, {
                type: "name";
                match: string;
            }>]>;
            dockToEdge: z.ZodObject<{
                enabled: z.ZodBoolean;
                edge: z.ZodNullable<z.ZodEnum<["top", "right", "bottom", "left"]>>;
                windowMargin: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                enabled: boolean;
                edge: "top" | "right" | "bottom" | "left" | null;
                windowMargin: string;
            }, {
                enabled: boolean;
                edge: "top" | "right" | "bottom" | "left" | null;
                windowMargin: string;
            }>;
        }, "strip", z.ZodTypeAny, {
            name: string;
            anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
            offsetX: string;
            offsetY: string;
            width: string;
            height: string;
            monitorSelection: {
                type: "all";
            } | {
                type: "primary";
            } | {
                type: "secondary";
            } | {
                type: "index";
                match: number;
            } | {
                type: "name";
                match: string;
            };
            dockToEdge: {
                enabled: boolean;
                edge: "top" | "right" | "bottom" | "left" | null;
                windowMargin: string;
            };
        }, {
            name: string;
            anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
            offsetX: string;
            offsetY: string;
            width: string;
            height: string;
            monitorSelection: {
                type: "all";
            } | {
                type: "primary";
            } | {
                type: "secondary";
            } | {
                type: "index";
                match: number;
            } | {
                type: "name";
                match: string;
            };
            dockToEdge: {
                enabled: boolean;
                edge: "top" | "right" | "bottom" | "left" | null;
                windowMargin: string;
            };
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        name: string;
        htmlPath: string;
        zOrder: "normal" | "top_most" | "bottom_most";
        shownInTaskbar: boolean;
        focused: boolean;
        resizable: boolean;
        transparent: boolean;
        includeFiles: string[];
        caching: {
            defaultDuration: number;
            rules: {
                urlRegex: string;
                duration: number;
            }[];
        };
        privileges: {
            shellCommands: {
                program: string;
                argsRegex: string;
            }[];
        };
        presets: {
            name: string;
            anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
            offsetX: string;
            offsetY: string;
            width: string;
            height: string;
            monitorSelection: {
                type: "all";
            } | {
                type: "primary";
            } | {
                type: "secondary";
            } | {
                type: "index";
                match: number;
            } | {
                type: "name";
                match: string;
            };
            dockToEdge: {
                enabled: boolean;
                edge: "top" | "right" | "bottom" | "left" | null;
                windowMargin: string;
            };
        }[];
    }, {
        name: string;
        htmlPath: string;
        zOrder: "normal" | "top_most" | "bottom_most";
        shownInTaskbar: boolean;
        focused: boolean;
        resizable: boolean;
        transparent: boolean;
        caching: {
            defaultDuration: number;
            rules: {
                urlRegex: string;
                duration: number;
            }[];
        };
        privileges: {
            shellCommands: {
                program: string;
                argsRegex: string;
            }[];
        };
        presets: {
            name: string;
            anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
            offsetX: string;
            offsetY: string;
            width: string;
            height: string;
            monitorSelection: {
                type: "all";
            } | {
                type: "primary";
            } | {
                type: "secondary";
            } | {
                type: "index";
                match: number;
            } | {
                type: "name";
                match: string;
            };
            dockToEdge: {
                enabled: boolean;
                edge: "top" | "right" | "bottom" | "left" | null;
                windowMargin: string;
            };
        }[];
        includeFiles?: string[] | undefined;
    }>;
    widgetPack: z.ZodObject<{
        name: z.ZodString;
        version: z.ZodString;
        description: z.ZodString;
        tags: z.ZodArray<z.ZodString, "many">;
        previewImages: z.ZodArray<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>, "many">;
        widgets: z.ZodArray<z.ZodObject<{
            name: z.ZodString;
            htmlPath: z.ZodEffects<z.ZodString, string, string>;
            zOrder: z.ZodEnum<["normal", "top_most", "bottom_most"]>;
            shownInTaskbar: z.ZodBoolean;
            focused: z.ZodBoolean;
            resizable: z.ZodBoolean;
            transparent: z.ZodBoolean;
            includeFiles: z.ZodDefault<z.ZodArray<z.ZodString, "many">>;
            caching: z.ZodObject<{
                defaultDuration: z.ZodNumber;
                rules: z.ZodArray<z.ZodObject<{
                    urlRegex: z.ZodString;
                    duration: z.ZodNumber;
                }, "strip", z.ZodTypeAny, {
                    urlRegex: string;
                    duration: number;
                }, {
                    urlRegex: string;
                    duration: number;
                }>, "many">;
            }, "strip", z.ZodTypeAny, {
                defaultDuration: number;
                rules: {
                    urlRegex: string;
                    duration: number;
                }[];
            }, {
                defaultDuration: number;
                rules: {
                    urlRegex: string;
                    duration: number;
                }[];
            }>;
            privileges: z.ZodObject<{
                shellCommands: z.ZodArray<z.ZodObject<{
                    program: z.ZodString;
                    argsRegex: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    program: string;
                    argsRegex: string;
                }, {
                    program: string;
                    argsRegex: string;
                }>, "many">;
            }, "strip", z.ZodTypeAny, {
                shellCommands: {
                    program: string;
                    argsRegex: string;
                }[];
            }, {
                shellCommands: {
                    program: string;
                    argsRegex: string;
                }[];
            }>;
            presets: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                anchor: z.ZodEnum<["top_left", "top_center", "top_right", "center_left", "center", "center_right", "bottom_left", "bottom_center", "bottom_right"]>;
                offsetX: z.ZodString;
                offsetY: z.ZodString;
                width: z.ZodString;
                height: z.ZodString;
                monitorSelection: z.ZodUnion<[z.ZodObject<{
                    type: z.ZodLiteral<"all">;
                }, "strip", z.ZodTypeAny, {
                    type: "all";
                }, {
                    type: "all";
                }>, z.ZodObject<{
                    type: z.ZodLiteral<"primary">;
                }, "strip", z.ZodTypeAny, {
                    type: "primary";
                }, {
                    type: "primary";
                }>, z.ZodObject<{
                    type: z.ZodLiteral<"secondary">;
                }, "strip", z.ZodTypeAny, {
                    type: "secondary";
                }, {
                    type: "secondary";
                }>, z.ZodObject<{
                    type: z.ZodLiteral<"index">;
                    match: z.ZodNumber;
                }, "strip", z.ZodTypeAny, {
                    type: "index";
                    match: number;
                }, {
                    type: "index";
                    match: number;
                }>, z.ZodObject<{
                    type: z.ZodLiteral<"name">;
                    match: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    type: "name";
                    match: string;
                }, {
                    type: "name";
                    match: string;
                }>]>;
                dockToEdge: z.ZodObject<{
                    enabled: z.ZodBoolean;
                    edge: z.ZodNullable<z.ZodEnum<["top", "right", "bottom", "left"]>>;
                    windowMargin: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    enabled: boolean;
                    edge: "top" | "right" | "bottom" | "left" | null;
                    windowMargin: string;
                }, {
                    enabled: boolean;
                    edge: "top" | "right" | "bottom" | "left" | null;
                    windowMargin: string;
                }>;
            }, "strip", z.ZodTypeAny, {
                name: string;
                anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
                offsetX: string;
                offsetY: string;
                width: string;
                height: string;
                monitorSelection: {
                    type: "all";
                } | {
                    type: "primary";
                } | {
                    type: "secondary";
                } | {
                    type: "index";
                    match: number;
                } | {
                    type: "name";
                    match: string;
                };
                dockToEdge: {
                    enabled: boolean;
                    edge: "top" | "right" | "bottom" | "left" | null;
                    windowMargin: string;
                };
            }, {
                name: string;
                anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
                offsetX: string;
                offsetY: string;
                width: string;
                height: string;
                monitorSelection: {
                    type: "all";
                } | {
                    type: "primary";
                } | {
                    type: "secondary";
                } | {
                    type: "index";
                    match: number;
                } | {
                    type: "name";
                    match: string;
                };
                dockToEdge: {
                    enabled: boolean;
                    edge: "top" | "right" | "bottom" | "left" | null;
                    windowMargin: string;
                };
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            htmlPath: string;
            zOrder: "normal" | "top_most" | "bottom_most";
            shownInTaskbar: boolean;
            focused: boolean;
            resizable: boolean;
            transparent: boolean;
            includeFiles: string[];
            caching: {
                defaultDuration: number;
                rules: {
                    urlRegex: string;
                    duration: number;
                }[];
            };
            privileges: {
                shellCommands: {
                    program: string;
                    argsRegex: string;
                }[];
            };
            presets: {
                name: string;
                anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
                offsetX: string;
                offsetY: string;
                width: string;
                height: string;
                monitorSelection: {
                    type: "all";
                } | {
                    type: "primary";
                } | {
                    type: "secondary";
                } | {
                    type: "index";
                    match: number;
                } | {
                    type: "name";
                    match: string;
                };
                dockToEdge: {
                    enabled: boolean;
                    edge: "top" | "right" | "bottom" | "left" | null;
                    windowMargin: string;
                };
            }[];
        }, {
            name: string;
            htmlPath: string;
            zOrder: "normal" | "top_most" | "bottom_most";
            shownInTaskbar: boolean;
            focused: boolean;
            resizable: boolean;
            transparent: boolean;
            caching: {
                defaultDuration: number;
                rules: {
                    urlRegex: string;
                    duration: number;
                }[];
            };
            privileges: {
                shellCommands: {
                    program: string;
                    argsRegex: string;
                }[];
            };
            presets: {
                name: string;
                anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
                offsetX: string;
                offsetY: string;
                width: string;
                height: string;
                monitorSelection: {
                    type: "all";
                } | {
                    type: "primary";
                } | {
                    type: "secondary";
                } | {
                    type: "index";
                    match: number;
                } | {
                    type: "name";
                    match: string;
                };
                dockToEdge: {
                    enabled: boolean;
                    edge: "top" | "right" | "bottom" | "left" | null;
                    windowMargin: string;
                };
            }[];
            includeFiles?: string[] | undefined;
        }>, "many">;
        repositoryUrl: z.ZodUnion<[z.ZodString, z.ZodLiteral<"">]>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        version: string;
        description: string;
        tags: string[];
        previewImages: string[];
        widgets: {
            name: string;
            htmlPath: string;
            zOrder: "normal" | "top_most" | "bottom_most";
            shownInTaskbar: boolean;
            focused: boolean;
            resizable: boolean;
            transparent: boolean;
            includeFiles: string[];
            caching: {
                defaultDuration: number;
                rules: {
                    urlRegex: string;
                    duration: number;
                }[];
            };
            privileges: {
                shellCommands: {
                    program: string;
                    argsRegex: string;
                }[];
            };
            presets: {
                name: string;
                anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
                offsetX: string;
                offsetY: string;
                width: string;
                height: string;
                monitorSelection: {
                    type: "all";
                } | {
                    type: "primary";
                } | {
                    type: "secondary";
                } | {
                    type: "index";
                    match: number;
                } | {
                    type: "name";
                    match: string;
                };
                dockToEdge: {
                    enabled: boolean;
                    edge: "top" | "right" | "bottom" | "left" | null;
                    windowMargin: string;
                };
            }[];
        }[];
        repositoryUrl: string;
    }, {
        name: string;
        version: string;
        description: string;
        tags: string[];
        previewImages: string[];
        widgets: {
            name: string;
            htmlPath: string;
            zOrder: "normal" | "top_most" | "bottom_most";
            shownInTaskbar: boolean;
            focused: boolean;
            resizable: boolean;
            transparent: boolean;
            caching: {
                defaultDuration: number;
                rules: {
                    urlRegex: string;
                    duration: number;
                }[];
            };
            privileges: {
                shellCommands: {
                    program: string;
                    argsRegex: string;
                }[];
            };
            presets: {
                name: string;
                anchor: "top_left" | "top_center" | "top_right" | "center_left" | "center" | "center_right" | "bottom_left" | "bottom_center" | "bottom_right";
                offsetX: string;
                offsetY: string;
                width: string;
                height: string;
                monitorSelection: {
                    type: "all";
                } | {
                    type: "primary";
                } | {
                    type: "secondary";
                } | {
                    type: "index";
                    match: number;
                } | {
                    type: "name";
                    match: string;
                };
                dockToEdge: {
                    enabled: boolean;
                    edge: "top" | "right" | "bottom" | "left" | null;
                    windowMargin: string;
                };
            }[];
            includeFiles?: string[] | undefined;
        }[];
        repositoryUrl: string;
    }>;
};

type DockConfig = {
    enabled: boolean;
    edge: 'top' | 'bottom' | 'left' | 'right' | null;
    windowMargin: string;
};

type MonitorSelection = {
    type: 'all' | 'primary' | 'secondary';
} | {
    type: 'index';
    match: number;
} | {
    type: 'name';
    match: string;
};

type WidgetCaching = {
    defaultDuration: number;
    rules: WidgetCachingRule[];
};
type WidgetCachingRule = {
    urlRegex: string;
    duration: number;
};

type WidgetPlacement = {
    anchor: 'top_left' | 'top_center' | 'top_right' | 'center_left' | 'center' | 'center_right' | 'bottom_left' | 'bottom_center' | 'bottom_right';
    offsetX: string;
    offsetY: string;
    width: string;
    height: string;
    monitorSelection: MonitorSelection;
    dockToEdge: DockConfig;
};

type WidgetPreset = {
    name: string;
} & WidgetPlacement;

type WidgetPrivileges = {
    shellCommands: AllowedShellCommand[];
};
type AllowedShellCommand = {
    program: string;
    argsRegex: string;
};

type WidgetConfig = {
    name: string;
    htmlPath: string;
    zOrder: 'normal' | 'top_most' | 'bottom_most';
    shownInTaskbar: boolean;
    focused: boolean;
    resizable: boolean;
    transparent: boolean;
    includeFiles: string[];
    caching: WidgetCaching;
    privileges: WidgetPrivileges;
    presets: WidgetPreset[];
};

type WidgetPack = {
    type: 'marketplace';
    id: string;
    name: string;
    version: string;
    previewImages: string[];
    repositoryUrl: string;
    directoryPath: string;
    description: string;
    widgets: WidgetConfig[];
    tags: string[];
    metadata: {
        packId: string;
        installedAt: number;
        version: string;
    };
} | {
    type: 'custom';
    id: string;
    name: string;
    version: string;
    previewImages: string[];
    repositoryUrl: string;
    directoryPath: string;
    description: string;
    widgets: WidgetConfig[];
    tags: string[];
};

interface BatteryProviderConfig {
    type: 'battery';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type BatteryProvider = Provider<BatteryProviderConfig, BatteryOutput>;
interface BatteryOutput {
    chargePercent: number;
    cycleCount: number;
    healthPercent: number;
    powerConsumption: number;
    state: 'discharging' | 'charging' | 'full' | 'empty' | 'unknown';
    isCharging: boolean;
    timeTillEmpty: number | null;
    timeTillFull: number | null;
    voltage: number | null;
}

interface CpuProviderConfig {
    type: 'cpu';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type CpuProvider = Provider<CpuProviderConfig, CpuOutput>;
interface CpuOutput {
    frequency: number;
    usage: number;
    logicalCoreCount: number;
    physicalCoreCount: number;
    vendor: string;
}

interface DateProviderConfig {
    type: 'date';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
    /**
     * Either a UTC offset (eg. `UTC+8`) or an IANA timezone (eg.
     * `America/New_York`). Affects the output of {@link DateOutput.formatted}.
     *
     * A full list of available IANA timezones can be found [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
     */
    timezone?: string;
    /**
     * An ISO-639-1 locale, which is either a 2-letter language code
     * (eg. `en`) or a 4-letter language + country code (eg. `en-gb`).
     * Affects the output of {@link DateOutput.formatted}.
     *
     * A full list of ISO-639-1 locales can be found [here](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes#Table).
     */
    locale?: string;
    /**
     * Formatting of the current date into a custom string format. Affects
     * the output of {@link DateOutput.formatted}.
     *
     * Refer to [table of tokens](https://moment.github.io/luxon/#/formatting?id=table-of-tokens)
     * for available date/time tokens.
     *
     * @example
     * "yyyy LLL dd" -> "2023 Feb 13"
     * "HH 'hours and' mm 'minutes'" -> "20 hours and 55 minutes"
     */
    formatting?: string;
}
type DateProvider = Provider<DateProviderConfig, DateOutput>;
interface DateOutput {
    /**
     * Current date/time as a formatted string.
     */
    formatted: string;
    /**
     * Current date/time as a JavaScript `Date` object. Uses `new Date()` under
     * the hood.
     **/
    new: Date;
    /**
     * Current date/time as milliseconds since epoch. Uses `Date.now()` under the
     * hood.
     **/
    now: number;
    /**
     * Current date/time as an ISO-8601 string (eg.
     * `2017-04-22T20:47:05.335-04:00`). Uses `date.toISOString()` under the hood.
     **/
    iso: string;
}

interface GlazeWmProviderConfig {
    type: 'glazewm';
}
type GlazeWmProvider = Provider<GlazeWmProviderConfig, GlazeWmOutput>;
interface GlazeWmOutput {
    /**
     * Workspace displayed on the current monitor.
     */
    displayedWorkspace: Workspace;
    /**
     * Workspace that currently has focus (on any monitor).
     */
    focusedWorkspace: Workspace;
    /**
     * Workspaces on the current monitor.
     */
    currentWorkspaces: Workspace[];
    /**
     * Workspaces across all monitors.
     */
    allWorkspaces: Workspace[];
    /**
     * All monitors.
     */
    allMonitors: Monitor[];
    /**
     * All windows.
     */
    allWindows: Window[];
    /**
     * Monitor that currently has focus.
     */
    focusedMonitor: Monitor;
    /**
     * Monitor that is nearest to this Zebar widget.
     */
    currentMonitor: Monitor;
    /**
     * Container that currently has focus (on any monitor).
     */
    focusedContainer: Container;
    /**
     * Tiling direction of the focused container.
     */
    tilingDirection: TilingDirection;
    /**
     * Active binding modes;
     */
    bindingModes: BindingModeConfig[];
    /**
     * Whether GlazeWM is currently paused.
     */
    isPaused: boolean;
    /**
     * Invokes a WM command (e.g. `"focus --workspace 1"`).
     *
     * @param command WM command to run (e.g. `"focus --workspace 1"`).
     * @param subjectContainerId (optional) ID of container to use as subject.
     * If not provided, this defaults to the currently focused container.
     * @throws If command fails.
     */
    runCommand(command: string, subjectContainerId?: string): Promise<RunCommandResponse>;
}

interface HostProviderConfig {
    type: 'host';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type HostProvider = Provider<HostProviderConfig, HostOutput>;
interface HostOutput {
    hostname: string | null;
    osName: string | null;
    osVersion: string | null;
    friendlyOsVersion: string | null;
    bootTime: number;
    uptime: number;
}

interface IpProviderConfig {
    type: 'ip';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type IpProvider = Provider<IpProviderConfig, IpOutput>;
interface IpOutput {
    address: string;
    approxCity: string;
    approxCountry: string;
    approxLatitude: number;
    approxLongitude: number;
}

interface KeyboardProviderConfig {
    type: 'keyboard';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type KeyboardProvider = Provider<KeyboardProviderConfig, KeyboardOutput>;
interface KeyboardOutput {
    layout: string;
}

interface KomorebiProviderConfig {
    type: 'komorebi';
}
type KomorebiProvider = Provider<KomorebiProviderConfig, KomorebiOutput>;
interface KomorebiOutput {
    /**
     * Workspace displayed on the current monitor.
     */
    displayedWorkspace: KomorebiWorkspace;
    /**
     * Workspace that currently has focus (on any monitor).
     */
    focusedWorkspace: KomorebiWorkspace;
    /**
     * Workspaces on the current monitor.
     */
    currentWorkspaces: KomorebiWorkspace[];
    /**
     * Workspaces across all monitors.
     */
    allWorkspaces: KomorebiWorkspace[];
    /**
     * All monitors.
     */
    allMonitors: KomorebiMonitor[];
    /**
     * Monitor that currently has focus.
     */
    focusedMonitor: KomorebiMonitor;
    /**
     * Monitor that is nearest to this Zebar widget.
     */
    currentMonitor: KomorebiMonitor;
}
interface KomorebiResponse {
    allMonitors: KomorebiMonitor[];
    focusedMonitorIndex: number;
}
interface KomorebiMonitor {
    id: number;
    deviceId: string;
    focusedWorkspaceIndex: number;
    name: string;
    size: KomorebiRect;
    workAreaOffset: number | null;
    workAreaSize: KomorebiRect;
    workspaces: KomorebiWorkspace[];
}
interface KomorebiWorkspace {
    containerPadding: number | null;
    floatingWindows: KomorebiWindow[];
    focusedContainerIndex: number;
    latestLayout: KomorebiRect[];
    layout: KomorebiLayout;
    layoutFlip: KomorebiLayoutFlip | null;
    maximizedWindow: KomorebiWindow | null;
    monocleContainer: KomorebiContainer | null;
    name: string | null;
    tilingContainers: KomorebiContainer[];
    workspacePadding: number | null;
}
interface KomorebiContainer {
    id: string;
    windows: KomorebiWindow[];
}
interface KomorebiWindow {
    class: string | null;
    exe: string | null;
    hwnd: number;
    title: string | null;
}
interface KomorebiRect {
    left: number;
    top: number;
    right: number;
    bottom: number;
}
type KomorebiLayout = 'bsp' | 'vertical_stack' | 'horizontal_stack' | 'ultrawide_vertical_stack' | 'rows' | 'grid' | 'right_main_vertical_stack' | 'custom';
type KomorebiLayoutFlip = 'horizontal' | 'vertical' | 'horizontal_and_vertical';

interface MediaProviderConfig {
    type: 'media';
}
interface MediaOutput {
    /** @deprecated Use {@link currentSession} instead */
    session: MediaSession | null;
    currentSession: MediaSession | null;
    allSessions: MediaSession[];
    play(options?: MediaControlOptions): void;
    pause(options?: MediaControlOptions): void;
    togglePlayPause(options?: MediaControlOptions): void;
    next(options?: MediaControlOptions): void;
    previous(options?: MediaControlOptions): void;
}
interface MediaControlOptions {
    sessionId?: string;
}
interface MediaSession {
    sessionId: string;
    title: string | null;
    artist: string | null;
    albumTitle: string | null;
    albumArtist: string | null;
    trackNumber: number;
    startTime: number;
    endTime: number;
    position: number;
    isPlaying: boolean;
    isCurrentSession: boolean;
}
type MediaProvider = Provider<MediaProviderConfig, MediaOutput>;

interface MemoryProviderConfig {
    type: 'memory';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type MemoryProvider = Provider<MemoryProviderConfig, MemoryOutput>;
interface MemoryOutput {
    usage: number;
    freeMemory: number;
    usedMemory: number;
    totalMemory: number;
    freeSwap: number;
    usedSwap: number;
    totalSwap: number;
}

interface DataSizeMeasure {
    bytes: number;
    siValue: number;
    siUnit: string;
    iecValue: number;
    iecUnit: string;
}

interface NetworkProviderConfig {
    type: 'network';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type NetworkProvider = Provider<NetworkProviderConfig, NetworkOutput>;
interface NetworkOutput {
    defaultInterface: NetworkInterface | null;
    defaultGateway: NetworkGateway | null;
    interfaces: NetworkInterface[];
    traffic: NetworkTraffic | null;
}
interface NetworkInterface {
    name: string;
    friendlyName: string | null;
    description: string | null;
    type: InterfaceType;
    ipv4Addresses: string[];
    ipv6Addresses: string[];
    macAddress: string | null;
    transmitSeed: number | null;
    receiveSpeed: number | null;
    dnsServers: string[];
    isDefault: boolean;
}
interface NetworkGateway {
    macAddress: string;
    ipv4Addresses: string[];
    ipv6Addresses: string[];
    ssid: string | null;
    signalStrength: number | null;
}
type InterfaceType = 'unknown' | 'ethernet' | 'token_ring' | 'fddi' | 'ppp' | 'loopback' | 'slip' | 'atm' | 'generic_modem' | 'proprietary_virtual' | 'isdn' | 'wifi' | 'dsl' | 'tunnel' | 'high_performance_serial_bus' | 'mobile_broadband' | 'bridge' | 'can';
interface NetworkTraffic {
    received: DataSizeMeasure;
    totalReceived: DataSizeMeasure;
    transmitted: DataSizeMeasure;
    totalTransmitted: DataSizeMeasure;
}

interface WeatherProviderConfig {
    type: 'weather';
    /**
     * Latitude to retrieve weather for. If not provided, latitude is instead
     * estimated based on public IP.
     */
    latitude?: number;
    /**
     * Longitude to retrieve weather for. If not provided, longitude is instead
     * estimated based on public IP.
     */
    longitude?: number;
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type WeatherProvider = Provider<WeatherProviderConfig, WeatherOutput>;
interface WeatherOutput {
    isDaytime: boolean;
    status: WeatherStatus;
    celsiusTemp: number;
    fahrenheitTemp: number;
    windSpeed: number;
}
type WeatherStatus = 'clear_day' | 'clear_night' | 'cloudy_day' | 'cloudy_night' | 'light_rain_day' | 'light_rain_night' | 'heavy_rain_day' | 'heavy_rain_night' | 'snow_day' | 'snow_night' | 'thunder_day' | 'thunder_night';

interface DiskProviderConfig {
    type: 'disk';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type DiskProvider = Provider<DiskProviderConfig, DiskOutput>;
interface Disk {
    name: string | null;
    fileSystem: string;
    mountPoint: string;
    totalSpace: DataSizeMeasure;
    availableSpace: DataSizeMeasure;
    isRemovable: boolean;
    driveType: string;
}
interface DiskOutput {
    disks: Disk[];
}

interface SystrayProviderConfig {
    type: 'systray';
}
type SystrayProvider = Provider<SystrayProviderConfig, SystrayOutput>;
interface SystrayOutput {
    icons: SystrayIcon[];
    onHoverEnter: (iconId: string) => Promise<void>;
    onHoverLeave: (iconId: string) => Promise<void>;
    onHoverMove: (iconId: string) => Promise<void>;
    onRightClick: (iconId: string) => Promise<void>;
    onLeftClick: (iconId: string) => Promise<void>;
    onMiddleClick: (iconId: string) => Promise<void>;
}
interface SystrayIcon {
    id: string;
    iconBytes: number[];
    iconBlob: Blob;
    iconHash: string;
    iconUrl: string;
    tooltip: string;
}

interface ProviderConfigMap {
    audio: AudioProviderConfig;
    battery: BatteryProviderConfig;
    cpu: CpuProviderConfig;
    date: DateProviderConfig;
    glazewm: GlazeWmProviderConfig;
    host: HostProviderConfig;
    ip: IpProviderConfig;
    komorebi: KomorebiProviderConfig;
    media: MediaProviderConfig;
    memory: MemoryProviderConfig;
    network: NetworkProviderConfig;
    weather: WeatherProviderConfig;
    keyboard: KeyboardProviderConfig;
    disk: DiskProviderConfig;
    systray: SystrayProviderConfig;
}
interface ProviderMap {
    audio: AudioProvider;
    battery: BatteryProvider;
    cpu: CpuProvider;
    date: DateProvider;
    glazewm: GlazeWmProvider;
    host: HostProvider;
    ip: IpProvider;
    komorebi: KomorebiProvider;
    media: MediaProvider;
    memory: MemoryProvider;
    network: NetworkProvider;
    weather: WeatherProvider;
    keyboard: KeyboardProvider;
    disk: DiskProvider;
    systray: SystrayProvider;
}
type ProviderType = keyof ProviderConfigMap;
type ProviderConfig = ProviderConfigMap[keyof ProviderConfigMap];
type ProviderOutput = ProviderMap[keyof ProviderMap]['output'];
/**
 * Creates a provider, which is a collection of functions and variables
 * that can change over time. Alternatively, multiple providers can be
 * created using {@link createProviderGroup}.
 *
 * The provider will continue to output until its `stop` function is
 * called.
 *
 * @throws If the provider config is invalid. Errors are emitted via the
 * `onError` method.
 */
declare function createProvider<T extends ProviderConfig>(config: T): ProviderMap[T['type']];

interface Provider<TConfig, TOutput> {
    /**
     * Latest output emitted from the provider.
     *
     * `null` if the latest emission from the provider is an error.
     */
    output: TOutput | null;
    /**
     * Latest error message emitted from the provider.
     *
     * `null` if the latest emission from the provider is a valid output.
     */
    error: string | null;
    /**
     * Whether the latest emission from the provider is an error.
     */
    hasError: boolean;
    /**
     * Underlying config for the provider.
     */
    config: TConfig;
    /**
     * Restarts the provider.
     */
    restart(): Promise<void>;
    /**
     * Stops the provider.
     */
    stop(): Promise<void>;
    /**
     * Listens for outputs from the provider.
     *
     * @param callback - Callback to run when an output is emitted.
     */
    onOutput(callback: (output: TOutput) => void): void;
    /**
     * Listens for errors from the provider.
     *
     * @param callback - Callback to run when an error is emitted.
     */
    onError(callback: (error: string) => void): void;
}

interface AudioProviderConfig {
    type: 'audio';
}
type AudioProvider = Provider<AudioProviderConfig, AudioOutput>;
interface AudioOutput {
    defaultPlaybackDevice: AudioDevice | null;
    defaultRecordingDevice: AudioDevice | null;
    playbackDevices: AudioDevice[];
    recordingDevices: AudioDevice[];
    setVolume(volume: number, options?: SetVolumeOptions): Promise<void>;
    setMute(mute: boolean, options?: SetMuteOptions): Promise<void>;
}
interface SetVolumeOptions {
    deviceId?: string;
}
interface SetMuteOptions {
    deviceId?: string;
}
interface AudioDevice {
    deviceId: string;
    name: string;
    volume: number;
    type: AudioDeviceType;
    isDefaultPlayback: boolean;
    isDefaultRecording: boolean;
    isMuted: boolean;
}
type AudioDeviceType = 'playback' | 'recording';

/**
 * Config for creating multiple provider instances at once.
 *
 * Keys are unique identifiers for the provider instance, values are their
 * respective configs.
 */
type ProviderGroupConfig = {
    [name: string]: ProviderConfig;
};
type ProviderGroup<T extends ProviderGroupConfig> = {
    /**
     * A map of combined provider outputs. Each key corresponds to a provider
     * name, and each value is the output of that provider.
     */
    outputMap: {
        [TName in keyof T]: ProviderMap[T[TName]['type']]['output'];
    };
    /**
     * A map of combined provider errors. Each key corresponds to a provider
     * name, and each value is the error of that provider.
     */
    errorMap: {
        [TName in keyof T]: ProviderMap[T[TName]['type']]['error'];
    };
    /**
     * Whether the latest emission from any provider in the group is an
     * error.
     */
    hasErrors: boolean;
    /**
     * Underlying providers in the group.
     */
    raw: {
        [TName in keyof T]: ProviderMap[T[TName]['type']];
    };
    /**
     * Config for the provider group.
     */
    configMap: T;
    /**
     * Listens for outputs from any provider in the group.
     *
     * @param callback - Callback to run when an output is emitted.
     */
    onOutput: (callback: (outputMap: ProviderGroup<T>['outputMap']) => void) => void;
    /**
     * Listens for errors from any provider in the group.
     *
     * @param callback - Callback to run when an error is emitted.
     */
    onError: (callback: (errorMap: ProviderGroup<T>['errorMap']) => void) => void;
    /**
     * Restarts all providers in the group.
     */
    restartAll(): Promise<void>;
    /**
     * Stops all providers in the group.
     */
    stopAll(): Promise<void>;
};
/**
 * Creates multiple providers at once. A provider is a collection of
 * functions and variables that can change over time. Alternatively, a
 * single provider can be created using {@link createProvider}.
 */
declare function createProviderGroup<T extends ProviderGroupConfig>(configMap: T): ProviderGroup<T>;

interface ShellCommandOptions {
    /**
     * Current working directory.
     */
    cwd?: string;
    /**
     * Environment variables.
     */
    env?: Record<string, string> | null;
    /**
     * Clear the environment variables of the spawned process.
     */
    clearEnv?: boolean;
    /**
     * Character encoding for stdout/stderr.
     *
     * Defaults to `utf-8` (string). Use `raw` to return raw bytes
     * (`Uint8Array`).
     */
    encoding?: ShellOutputEncoding;
}
type ShellOutputEncoding = 'raw' | 'utf-8' | 'utf-16' | 'gbk' | 'gb18030' | 'big5' | 'euc-jp' | 'euc-kr' | 'iso-2022-jp' | 'shift-jis';
interface ShellExecOutput<TOutput extends string | Uint8Array = string> {
    code: number | null;
    signal: number | null;
    stdout: TOutput;
    stderr: TOutput;
}

/**
 * Executes a shell command and waits for completion.
 *
 * @example
 * ```ts
 * const curl = await zebar.shellExec('curl', 'https://www.google.com');
 * console.log(curl.stdout);
 * ```
 *
 * @param {string} command - Path to program executable, or program name
 * (if in $PATH).
 * @param {string | string[]} args - Arguments to pass to the program.
 * @param {Object} options - Spawn options (optional).
 * @throws - If shell permissions are missing.
 */
declare function shellExec<TOutput extends string | Uint8Array = string>(program: string, args?: string | string[], options?: ShellCommandOptions): Promise<ShellExecOutput<TOutput>>;
/**
 * Starts a shell command without waiting for completion. Allows for
 * interaction with the spawned process, such as sending input and killing
 * the process.
 *
 * @example
 * ```ts
 * const ping = await zebar.shellSpawn('ping', '127.0.0.1 -n 10 -w 3000');
 * ping.onStdout(output => console.log('stdout', output));
 * ping.onStderr(output => console.log('stderr', output));
 * ping.onExit(output => console.log('exit', output));
 *
 * // Interacting with the process.
 * ping.write('Hello, world!');
 * ping.kill();
 * ```
 *
 * @param {string} command - Path to program executable, or program name
 * (if in $PATH).
 * @param {string | string[]} args - Arguments to pass to the program.
 * @param {Object} options - Spawn options (optional).
 * @throws - If shell permissions are missing.
 */
declare function shellSpawn<TOutput extends string | Uint8Array = string>(program: string, args?: string | string[], options?: ShellCommandOptions): Promise<ShellProcess<TOutput>>;
interface ShellProcess<TOutput extends string | Uint8Array = string> {
    processId: number;
    onStdout: (callback: (line: TOutput) => void) => void;
    onStderr: (callback: (line: TOutput) => void) => void;
    onExit: (callback: (status: {
        exitCode: number | null;
        signal: number | null;
    }) => void) => void;
    kill: () => void;
    write: (data: string | Uint8Array) => void;
}

interface Widget {
    /**
     * Unique identifier for the widget instance.
     */
    id: string;
    /**
     * Name of the widget.
     */
    name: string;
    /**
     * Unique identifier for the widget pack.
     */
    packId: string;
    /**
     * Absolute path to the widget's config file.
     */
    configPath: string;
    /**
     * Absolute path to the widget's HTML file.
     */
    htmlPath: string;
    /**
     * The window of the widget.
     *
     * @deprecated Use {@link tauriWindow} and {@link setZOrder} instead
     * (e.g. `currentWidget().setZOrder('bottom_most')`).
     */
    window: {
        get tauri(): ReturnType<typeof getCurrentWindow>;
        setZOrder(zOrder: ZOrder): Promise<void>;
    };
    /**
     * The underlying Tauri window.
     */
    tauriWindow: ReturnType<typeof getCurrentWindow>;
    /**
     * Whether the widget is in preview mode.
     *
     * Widgets get marked as previews if they are opened from another
     * preview widget.
     */
    isPreview: boolean;
    /**
     * Sets the z-order of the widget's window.
     */
    setZOrder(zOrder: ZOrder): Promise<void>;
    /**
     * Closes the widget's window.
     *
     * Same as calling `tauriWindow.close()`.
     */
    close(): Promise<void>;
}
declare function currentWidget(): Widget;
type ZOrder = 'bottom_most' | 'top_most' | 'normal';
interface StartWidgetArgs {
    packId?: string;
}
/**
 * Opens a widget by its name and chosen placement.
 */
declare function startWidget(widgetName: string, placement: WidgetPlacement, args: StartWidgetArgs): Promise<void>;
interface StartWidgetPresetArgs {
    packId?: string;
}
/**
 * Opens a widget by its name and a preset name.
 */
declare function startWidgetPreset(widgetName: string, presetName: string, args?: StartWidgetPresetArgs): Promise<void>;

export { type AllowedShellCommand, type AudioDevice, type AudioDeviceType, type AudioOutput, type AudioProvider, type AudioProviderConfig, type BatteryOutput, type BatteryProvider, type BatteryProviderConfig, type CpuOutput, type CpuProvider, type CpuProviderConfig, type DateOutput, type DateProvider, type DateProviderConfig, type Disk, type DiskOutput, type DiskProvider, type DiskProviderConfig, type DockConfig, type GlazeWmOutput, type GlazeWmProvider, type GlazeWmProviderConfig, type HostOutput, type HostProvider, type HostProviderConfig, type InterfaceType, type IpOutput, type IpProvider, type IpProviderConfig, type KeyboardOutput, type KeyboardProvider, type KeyboardProviderConfig, type KomorebiContainer, type KomorebiLayout, type KomorebiLayoutFlip, type KomorebiMonitor, type KomorebiOutput, type KomorebiProvider, type KomorebiProviderConfig, type KomorebiRect, type KomorebiResponse, type KomorebiWindow, type KomorebiWorkspace, type MediaControlOptions, type MediaOutput, type MediaProvider, type MediaProviderConfig, type MediaSession, type MemoryOutput, type MemoryProvider, type MemoryProviderConfig, type MonitorSelection, type NetworkGateway, type NetworkInterface, type NetworkOutput, type NetworkProvider, type NetworkProviderConfig, type NetworkTraffic, type ProviderConfig, type ProviderConfigMap, type ProviderGroup, type ProviderGroupConfig, type ProviderMap, type ProviderOutput, type ProviderType, type SetMuteOptions, type SetVolumeOptions, type SystrayIcon, type SystrayOutput, type SystrayProvider, type SystrayProviderConfig, type WeatherOutput, type WeatherProvider, type WeatherProviderConfig, type WeatherStatus, type Widget, type WidgetCaching, type WidgetCachingRule, type WidgetConfig, type WidgetPack, type WidgetPlacement, type WidgetPreset, type WidgetPrivileges, configSchemas, createProvider, createProviderGroup, currentWidget, shellExec, shellSpawn, startWidget, startWidgetPreset };
